from __future__ import absolute_import, print_function

import os

import sys
import invoke


@invoke.ctask
def qrc_mxgraph(
    ctx,
    folder=None,
):
    """
    Compiles mxGraph and qmxgraph own static web files in Qt resource files.

    This simplifies a lot embedding these contents on Qt web views. It also
    helps freezing an executable, as dependency with static web files becomes
    explicit in Python because of imported resource file.

    Generates 2 resource files located in `qmxgraph` package:

    * `resource_qmxgraph`: static files found in `page/` folder of qmxgraph;
    * `resource_mxgraph`: static files in mxGraph library, specifically
    all files located in `javascript/src`.

    These resources are imported by qmxgraph widget and must be generated
    before its use.
    """
    import qmxgraph

    from qmxgraph import deploy

    WEB_EXTENSIONS = (
        '.js',
        '.gif',
        '.png',
        '.html',
        '.css',
        '.txt',  # used by mxGraph resources
        '.xml',  # used by mxGraph resources
    )

    # identation_level = 0
    # ident = '    ' * identation_level

    # print_message(
    #     '{}qrc_web'.format(ident),
    #     color=Fore.BLUE, bright=True)

    def create_web_resource(resource_name, src_dir):
        # print_message(
        #     '{}    - resource: {}'.format(ident, resource_name),
        #     color=Fore.BLUE, bright=True)

        target_dir = os.path.dirname(qmxgraph.__file__)
        qrc_file, py_file = generate_qrc_from_folder(
            basename='resource_{}'.format(resource_name),
            alias=resource_name,
            source_dir=src_dir,
            target_dir=target_dir,
            include=WEB_EXTENSIONS,
        )
        # print_message('{}        * generated {}'.format(ident, qrc_file))
        # print_message('{}        * generated {}'.format(ident, py_file))

    if folder is None:
        # TODO fogo: raise if doesn't find conda
        env_dir = deploy.get_conda_env_path()
        if env_dir is None:
            raise IOError("Unable to determine MxGraph folder in environment")
        folder = '{env_dir}/mxgraph'.format(env_dir=env_dir)
    create_web_resource(
        resource_name='mxgraph',
        src_dir='{folder}/javascript/src'.format(folder=folder))

    qgraph_root = os.path.dirname(qmxgraph.__file__)
    create_web_resource(
        resource_name='qmxgraph',
        src_dir=os.path.join(qgraph_root, 'page'),
    )


@invoke.ctask
def test(
    ctx,
    xml=None,
):
    # project_name = get_project_name_for_cwd()
    # print_message(
    #     '{0} test (custom)'.format(project_name), color=Fore.BLUE,
    # bright=True)
    cmd = 'py.test'
    if xml:
        cmd += ' --junitxml={xml}'.format(xml=xml)

    import subprocess
    raise invoke.Exit(subprocess.call(cmd, shell=True))


def generate_qrc(target_filename, file_map):
    """
    Generates a Qt resource collection file. It is an XML file used to specify
    which resource files are to be embedded, using .qrc as extension.

    Consider call below:

    ```python
    generate_qrc('resource.qrc', ['foo/bar.txt', '/home/dent/bar.txt'])
    ```

    It would generate a .qrc file with contents like:

    ```
    <!DOCTYPE RCC>
    <RCC version="1.0">

    <qresource>
        <file alias="foo/bar.txt">/home/dent/bar.txt</file>
    </qresource>

    </RCC>
    ```

    Once compiled to a Python module (see `generate_qrc_py`), developer could
    access resource like this, for instance:

    ```python
    QFile(':/foo/bar.txt')
    ```

    References:
    * http://doc.qt.io/qt-5/resources.html
    * http://pyqt.sourceforge.net/Docs/PyQt5/resources.html

    :param str target_filename: Path of generated resource collection file.
    :param iterable[tuple[str, str]] file_map: A list of pairs. Each
        pair must be formed by, respectively, alias for file in resource
        collection and path of file to be included in resource collection.
    """
    write = generate_qrc_contents(file_map)
    # UTF-8 is the encoding adopted by Qt (and subsequently PyQt) resource
    # collection tools. It seems to not be officially stated anywhere in docs
    # unfortunately, but if it is possible to see this encoding in use by
    # Python modules generated by `pyrcc5`, for instance. Also one moderator
    # in a Qt official forum stated UTF-8 is Qt preference, which is the
    # closest thing to a official documentation about this choice (
    # https://forum.qt.io/topic/42641/the-qt-resource-system-compile-error/4).
    import io
    with io.open(target_filename, 'w', encoding='utf8') as f:
        f.write(write)


def generate_qrc_contents(file_map):
    """
    Generates just the contents of a Qt resource collection file. See
    `generate_qrc` for more details.

    :param iterable[tuple[str, str]] file_map: See `generate_qrc`.
    :rtype: str
    :return: Contents of a resource collection file.
    """
    entries = '\n'.join(
        [
            '    ' + QRC_ENTRY_TEMPLATE.format(alias=alias, path=path)
            for (alias, path) in file_map
        ]
    )
    return QRC_FILE_TEMPLATE.format(entries=entries)


def generate_qrc_py(qrc_filename, target_filename):
    """
    Generates a Python module that only needs to be imported by a Qt
    application in order for those resources to be made available just as if
    they were the original files.

    References:
    * http://doc.qt.io/qt-5/resources.html
    * http://pyqt.sourceforge.net/Docs/PyQt5/resources.html

    :param str qrc_filename: A .qrc resource collection file.
    :param str target_filename: Path of generated Python module.
    """
    import subprocess

    cwd, local_filename = os.path.split(qrc_filename)
    subprocess.check_call(
        ['pyrcc5', local_filename, '-o', target_filename], cwd=cwd)


def generate_qrc_from_folder(
        basename, alias, source_dir, target_dir, include=None):
    """
    Collect files from a folder, include them in a resource collection file and
    then compiles it to a Python module.

    All collected files are aliased in resource collection with relative path
    in source dir prefixed by `alias`.

    For instance, consider folder below:

    ```
    - /home/dent/foo/
        * file1.txt
        * file2.txt
        - bar/
            * file3.txt
    ```

    With a call like:

    ```python
    generate_qrc_from_folder(
        'resource_foo', 'rsc_foo', '/home/dent/foo/', '/home/dent/foo/')
    ```

    It would result in a .qrc like:

    ```
    <!DOCTYPE RCC>
    <RCC version="1.0">

    <qresource>
        <file alias="rsc_foo/file1.txt">/home/dent/foo/file1.txt</file>
        <file alias="rsc_foo/file2.txt">/home/dent/foo/file2.txt</file>
        <file alias="rsc_foo/bar/file3.txt">/home/dent/foo/bar/file3.txt</file>
    </qresource>

    </RCC>
    ```

    :param str basename: Basename used for .qrc and .py files generated
        for resource collection.
    :param str alias: Basename used for aliases in .qrc file.
    :param str source_dir: Folder that will have its files included in
        resource collection.
    :param str target_dir: Folder where generated .qrc and .py files are
        going to be written.
    :param iterable|None include: Allowed extensions to be collected, if None
        all are allowed.
    """
    if not os.path.isdir(source_dir):
        raise IOError("Invalid source directory: {}".format(source_dir))

    if not os.path.isdir(target_dir):
        raise IOError("Invalid target directory: {}".format(target_dir))

    if sys.platform.startswith('win'):
        def fix_alias(a):
            return a.replace('\\', '/')
    else:
        def fix_alias(a):
            return a

    files = [
        (
            fix_alias('{alias}/{rel_file}'.format(
                alias=alias,
                rel_file=os.path.relpath(f, source_dir))),
            f
        )
        for f in collect_files_in_folder(source_dir, include=include)
        ]
    if not files:
        raise RuntimeError(
            "Unable to collect anything for "
            ".qrc file in folder {}".format(source_dir))

    qrc_filename = os.path.join(
        target_dir, '{basename}{ext}'.format(basename=basename, ext='.qrc'))
    generate_qrc(qrc_filename, files)

    py_filename = os.path.join(target_dir, '{basename}{ext}'.format(
        basename=basename, ext='.py'))
    generate_qrc_py(qrc_filename, py_filename)

    return qrc_filename, py_filename


def collect_files_in_folder(folder, include=None):
    collected = []
    for root, dirs, files in os.walk(folder):
        for file_ in files:
            if include is None or os.path.splitext(file_)[1] in include:
                collected.append(os.path.normpath(os.path.join(root, file_)))

    return collected


QRC_ENTRY_TEMPLATE = '<file alias="{alias}">{path}</file>'
QRC_FILE_TEMPLATE = '''\
<!DOCTYPE RCC>
<RCC version="1.0">

<qresource>
{entries}
</qresource>

</RCC>'''


# Only task registered in this global collection will be detected by invoke.
ns = invoke.Collection()
ns.add_task(qrc_mxgraph)
ns.add_task(test)
